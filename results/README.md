# Лабораторная Lab3 SCR1 sim

## Задание

|Инструкция                                |Описание                            |
|------------------------------------------|----------------------------------- |
|Concatenation with upper immediate (CNCUI)|CNCUI: Конкатенация старших 20-bit константы<br> и младших 12-bit регистра RS1=RD, результат поместить в RD| 

## Выполнение

Для выполнения лабораторной работы были выполнены следующие действия:

### Добавление кастомной инструкции

1. Сначала выбираем опкод для новой инструкции, из спецификации(стр 129) видно, что есть 2 варианта custom 0(00010) и custom 1(01010), пусть это будет custom 1. Также в команде используется 20 страших битов константы, поэтому лучше всего подойдет использовать тип команды *U-type*, где как раз есть 30 битов для поля imm, rs1 равен rd, поэтому одного поля для регистра хватит.

2. Для этого в файл *[scr1_riscv_isa_decoding.svh](../src/includes/scr1_riscv_isa_decoding.svh)* в *type_scr1_rvi_opcode_e* добавляем новый опкод

    ```
        SCR1_OPCODE_CNCUI       = 5'b01010 // new opcode 
    ```

3. Также добавим в тот же файл в информацию которая передается из idu в exu *type_scr1_exu_cmd_s* дополнительный сигнал, который будет выставляться, если вызвана команда cncui. (Возможно это было можно реализовать более аккуратно, но как уж получилось уже)

    ```
        logic                               conc_req;       // additional dignal for new command
    ```

4. Теперь изменяем файл *[scr1_pipe_idu.sv](../src/core/pipeline/scr1_pipe_idu.sv)*, то есть то что будет происходить на стадии instruction decode:
    1. Добавляем стандартное значение для нового сигнала

    ```
        idu2exu_cmd_o.conc_req    = 1'b0;  // default value for additional signal
    ```

    2. Добавляем обработку нового опкода

    ```
        SCR1_OPCODE_CNCUI           : begin
                idu2exu_use_rd_o          = 1'b1; // инструкция использует rd
			    idu2exu_use_rs1_o         = 1'b1; // инструкция использует rs1
                idu2exu_use_imm_o         = 1'b1; // инструкция использует imm
			    idu2exu_cmd_o.conc_req    = 1'b1; // выставить 1 в новый доп. сигнал
			    idu2exu_cmd_o.rs1_addr    = instr[11:7]; // указать какие биты использовать для адреса rs1
                idu2exu_cmd_o.imm         = {instr[31:12], 12'b0}; // использовать только старшие 20 битов imm
			    idu2exu_cmd_o.ialu_op     = SCR1_IALU_OP_REG_IMM; // указать алу, что будет операция с полем imm
                idu2exu_cmd_o.ialu_cmd    = SCR1_IALU_CMD_ADD; // в алу будет сложение
		        idu2exu_cmd_o.rd_wb_sel   = SCR1_RD_WB_IALU; // результат алу записать в rd
    ```

5. Осталось изменить файл *[scr1_pipe_exu.sv](../src/core/pipeline/scr1_pipe_exu.sv)*, который отвечает за стадию execution
    1. В exu_queue укажем, чтобы сохранялось значение сигнала conc_req из idu2exu_cmd_i

        ```
            exu_queue.conc_req       <= idu2exu_cmd_i.conc_req;
        ```

    2. Если есть дополнительный сигнал, то использовать для op1 в алу только 12 младших битов значения, считанного из регистра по полученному адресу

        ```
            if (exu_queue.conc_req) // if cncui use 12 bits 
                ialu_main_op1 = {{20{1'b0}}, mprf2exu_rs1_data_i[11:0]};
            else
                ialu_main_op1 = mprf2exu_rs1_data_i;
            ialu_main_op2 = exu_queue.imm;
        ```

        На самом деле можно было не добавлять эту проверку на сигнал, а поменять другую строку, но у меня уже готовы все вейвформы и мало времени, чтобы заново выбрать все сигналы и написать объяснения. То что можно было по другому сделать, то есть в зависимости от наличия сигнала передавать либо все биты ialu_main_op1, либо только младшие 12.

        ```
            // IALU
            .exu2ialu_main_op1_i        (exu_queue.conc_req ? {{20{1'b0}}, ialu_main_op1[11:0]} : ialu_main_op1   ),
        ```

### Верификация

1. Для теста создана отдельная директория *[custom_inst](../sim/tests/custom_inst)*. Там находится сам тест *[cncui.S](../sim/tests/custom_inst/cncui.S)* и файлы для сборки, аналогичные тем, которые находятся в директории *[riscv_isa](../sim/tests/riscv_isa)*.

2. Добавлены измения в *[Makefile](../Makefile)*, чтобы сборку можно было запускать через *make run_verilator_wf*
    1. Дефолтное значение TRACE теперь 1

        ```
            # Use this parameter to enable tracelog
            TRACE ?= 1
        ```

    2. Закомментированы ненужные в данный момент тесты и добавлен свой тест для новой инструкции

        ```
            # Custom instruction test
            TARGETS += custom_inst
        ```

        ```
            custom_inst: | $(bld_dir)
                $(MAKE) -C $(tst_dir)/custom_inst ARCH=$(ARCH)
        ```

        ```
            $(MAKE) -C $(tst_dir)/custom_inst clean
        ```

3. В тесте рассмотрены 6 случаев
    1. Нулевое константное значение и нулевое значение в регистре, чтобы проверить что в в регистр будут записаны все нули, аналогично когда все единицы.

    2. Константное значение не 0, а в регистре старшие 20 битов нули, остальные 12 не нулевые, чтобы проверить, что конкантенация верно работает и 20 нулевых битов в регистре будут иметь значение 20 битов константы

    3. Константное значение не 0, а в регистре такое значение, что занимает больше 12 битов, чтобы проверить, что конкантенация верно работает и не будет простого сложения константы и значения регистра.

    4. Аналогичные 2 и 3 пунктам тесты только константное значение всегда ноль, чтобы проверить что в стращие 20 бит регистра ничегон не будет дописано.

4. Анализ вейвформ. В виде основных сигналов были выбраны значение опкода(rvi_opcode) и сигнала conc_req из idu и exu, чтобы показать, что при вызове команды с нужным опкодом conc_req будет равен 1.
Также добавлены значения полей imm и rs1_addr из idu и exu, чтобы показать, что при передаче из idu в exu значения будут верными.
Показаны значения mprf2exu_rs1_data_i и ialu_main_op1, что в первом будет полное значение, считанное из нужного регистра, а во втором только младшие 12 битов. 
И еще отображено значение ialu_main_res, чтобы показать, что окончательный результат верный.

## Результаты

* Из файла **signals.gtkw** можно понять, что все сигналы выставлются верно и полученные значения высиялются верно
* Аналогично значения можно проверить и по файлу **tracelog_core_0.log**, где видно, что в t0 будут записывать верные значения
* В файле **cncui.dump** видно, что все тесты правильно отображются.